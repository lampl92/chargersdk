/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.30                          *
*        Compiled Jul  1 2015, 10:50:32                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*
*   数据变化刷新;
*   需要刷新更新发送刷新数据消息
*   multi更新数据
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "touchtimer.h"
#include "SCROLLBAR.h"
#include "bsp_uart.h"
#include "ring_buffer.h"
// USER END

#include "DIALOG.h"
/*******************************************************************
*
*       defines
*
********************************************************************
*/
/*编辑窗口14行1列，状态项14个*/
#define _SYSEDIT_MAX_X 5
#define _SYSEDIT_MAX_Y 16
#define _SYSSTATUE_LINE 20
#define _SYSSTATUE_CAL 5
//后续将编辑和文本的滚轮方式用链表进行封装
#define _FONT_WIDTH 24
#define _WORD_WIDTH 20
static uint8_t _aahSysSet[_SYSEDIT_MAX_Y];
static EDIT_Handle   _aahEdit[_SYSEDIT_MAX_Y][_SYSEDIT_MAX_X];
static TEXT_Handle   _aahText[_SYSSTATUE_LINE][_SYSSTATUE_CAL];
static int _x,_y;
static uint8_t _checkbox;
MULTIEDIT_HANDLE multiedit_handler;
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0     (GUI_ID_USER + 0x00)
#define ID_IMAGE_0     (GUI_ID_USER + 0x1C)
// USER START (Optionally insert additional defines)
#define ID_TEXT_1     (GUI_ID_USER + 0x0B)
#define ID_TEXT_2     (GUI_ID_USER + 0x0C)
#define ID_TEXT_3     (GUI_ID_USER + 0x0D)
#define ID_TEXT_4     (GUI_ID_USER + 0x0E)

#define ID_TEXT_5  (GUI_ID_USER + 0x06)//
#define ID_EDIT_0  (GUI_ID_USER + 0x07)//
#define ID_TEXT_6  (GUI_ID_USER + 0x08)//
#define ID_TEXT_7  (GUI_ID_USER + 0x09)//
#define ID_TEXT_8  (GUI_ID_USER + 0x0A)//
#define ID_TEXT_9  (GUI_ID_USER + 0x0F)//
#define ID_TEXT_10  (GUI_ID_USER + 0x10)//
#define ID_TEXT_11  (GUI_ID_USER + 0x11)//
#define ID_EDIT_1  (GUI_ID_USER + 0x12)//
#define ID_EDIT_2  (GUI_ID_USER + 0x13)//
#define ID_EDIT_3  (GUI_ID_USER + 0x14)//
#define ID_EDIT_4  (GUI_ID_USER + 0x15)//
#define ID_EDIT_5  (GUI_ID_USER + 0x16)//
#define ID_EDIT_6  (GUI_ID_USER + 0x17)//
#define ID_MULTIEDIT_0 (GUI_ID_USER + 0x18)
#define ID_CHECKBOX_0 (GUI_ID_USER + 0x19)
#define ID_CHECKBOX_1 (GUI_ID_USER + 0x1A)
#define ID_TimerTime    1
#define ID_TimerFlush   2
#define ID_TimerSignal  3

#define sysEVSESN "交流桩SN"
#define sysEVSEID "交流桩ID"
#define sysServerIP "服务器IP"
#define sysServerPort "服务器端口"
#define sysUserName "用户名"
#define sysUserPwd "用户密码"
#define sysDispSleepTime "屏保时间"
#define sysUSEGPRSModem "GPRS类型"
// USER END
static WM_HWIN hWindow;
WM_HWIN _hWinManagerTerminate;
static WM_HTIMER _timerRTC,_timerData,_timerSignal;
char terminateBuff[30];
static int terminaterCount = 0;
static char strTermCtx[1500];
/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
// USER START (Optionally insert additional static data)
// USER END
/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] =
{
    { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 20, 40, 750, 300, 0, 0x0, 0 },
//	{ CHECKBOX_CreateIndirect, "Checkbox", ID_CHECKBOX_0, GUI_MANAGER_XLEFT + _FONT_WIDTH*(strlen(sysUSEGPRSModem)), GUI_MANAGER_YLEFT + GUI_MANAGER_YOFF*7, 90, 32, 0, 0x0, 0 },
//	{ CHECKBOX_CreateIndirect, "Checkbox", ID_CHECKBOX_1, GUI_MANAGER_XLEFT + _FONT_WIDTH*(strlen(sysUSEGPRSModem)) + 90, GUI_MANAGER_YLEFT + GUI_MANAGER_YOFF*7, 90, 32, 0, 0x0, 0 },
};
/*******************************************************************
*
*       _cbWindow

  The callback moves the edit-fiels when a notification message
  was send.
*/
static void _cbWindow(WM_MESSAGE *pMsg) {
    WM_SCROLL_STATE ScrollState;
    WM_HWIN      hItem;
    int x, y;
    volatile int id = 0;
    volatile int v = 0;
    char _tmpBuff[50];
    CON_t *pCon;
    pCon = CONGetHandle(0);

    switch (pMsg->MsgId)
    {
        case WM_NOTIFY_PARENT:
            /**< 添加两个滑轮的事件 */
            switch(WM_GetId(pMsg->hWinSrc))
            {
                case GUI_ID_HSCROLL://水平
                    if(pMsg->Data.v == WM_NOTIFICATION_VALUE_CHANGED)
                    {
                        /* 得到滚动条的状态，得到的数值好像是负值 才能使得 _x - ScrollState.v是正值 */
                        WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
                        if (_x != ScrollState.v)
                        {
                            for (y = 0; y < _SYSEDIT_MAX_Y; y++)
                            {
                                for (x = 0; x < _SYSEDIT_MAX_X; x++)
                                {
                                    WM_MoveWindow(_aahEdit[y][x], _x - ScrollState.v, 0);
                                    WM_MoveWindow(_aahText[y][x], _x - ScrollState.v, 0);
                                }
                            }
                            _x = ScrollState.v;
                        }
                    }
                break;
                case GUI_ID_VSCROLL:
                    if(pMsg->Data.v == WM_NOTIFICATION_VALUE_CHANGED)
                    {
                        WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
                        if (_y != ScrollState.v)
                        {
                            for (y = 0; y < _SYSEDIT_MAX_Y; y++)
                            {
                                for (x = 0; x < _SYSEDIT_MAX_X; x++)
                                {
                                    WM_MoveWindow(_aahEdit[y][x],0, _y - ScrollState.v);
                                    WM_MoveWindow(_aahText[y][x],0, _y - ScrollState.v);
                                }
                            }
                            _y = ScrollState.v;
                        }
                    }
                break;
            case 20:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 20, _hWinManagerTerminate, _hWinManagerCommon, sysEVSESN, "eg,1122334455667788");
                    //Keypad_GetValue(SYSSET_VALUE,"交流桩序列号");
//                    EDIT_SetText(_aahEdit[0][0], pEVSE->info.strSN);
                }
                break;
            case 21:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 21, _hWinManagerTerminate, _hWinManagerCommon, sysEVSEID, "eg,1122334455667788");
//                    memset(_tmpBuff, '\0', sizeof(_tmpBuff));
//                    sprintf(_tmpBuff, "%d", pEVSE->info.strID);
//                    EDIT_SetText(_aahEdit[1][0], _tmpBuff);
                }
                break;
            case 22:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 22, _hWinManagerTerminate, _hWinManagerCommon, sysServerIP, "eg,192.168.1.101");
//                    memset(_tmpBuff, '\0', sizeof(_tmpBuff));
//                    sprintf(_tmpBuff, "%d", pechProto->info.strServerIP);
//                    EDIT_SetText(_aahEdit[2][0], _tmpBuff);
                }
                break;
            case 23:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 23, _hWinManagerTerminate, _hWinManagerCommon, sysServerPort, "note:1~9999");
//                    memset(_tmpBuff, '\0', sizeof(_tmpBuff));
//                    sprintf(_tmpBuff, "%.1f", pechProto->info.usServerPort);
//                    EDIT_SetText(_aahEdit[3][0], _tmpBuff);
                }
                break;
            case 24:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 24, _hWinManagerTerminate, _hWinManagerCommon, sysUserName, "eg,dpc");
//                    EDIT_SetText(_aahEdit[4][0], pechProto->info.strUserName);
                }
                break;
            case 25:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 25, _hWinManagerTerminate, _hWinManagerCommon, sysUserPwd, "eg,8888");
//                    EDIT_SetText(_aahEdit[5][0], "******");
                }
                break;
            case 26:
                if (pMsg->Data.v == WM_NOTIFICATION_RELEASED)
                {
                    WM_HideWindow(_hWinManagerTerminate);
                    WM_HideWindow(_hWinManagerCommon);

                    Keypad_GetValueTest(SYSSET_VALUE, 26, _hWinManagerTerminate, _hWinManagerCommon, sysDispSleepTime, "note：5~60");
//                    memset(_tmpBuff, '\0', sizeof(_tmpBuff));
//                    sprintf(_tmpBuff, "%d", xSysconf.ulDispSleepTime_s);
//                    EDIT_SetText(_aahEdit[4][0], _tmpBuff);
                }
                break;
            }
            break;
        case WM_PAINT:
            /**< 绘制滑轮围绕区颜色 */
            GUI_SetBkColor(GUI_WHITE);
            GUI_Clear();
            break;
        case MSG_MANAGERSETID0:
            EDIT_SetText(_aahEdit[0][0],pEVSE->info.strSN);
            break;
        case MSG_MANAGERSETID1:
            EDIT_SetText(_aahEdit[1][0], pEVSE->info.strID);
            break;
        case MSG_MANAGERSETID2:
            EDIT_SetText(_aahEdit[2][0], pechProto->info.strServerIP);
            break;
        case MSG_MANAGERSETID3:
            sprintf(_tmpBuff,"%d",pechProto->info.usServerPort);
            EDIT_SetText(_aahEdit[3][0],_tmpBuff);
            break;
        case MSG_MANAGERSETID4:
            EDIT_SetText(_aahEdit[4][0],pechProto->info.strUserName);
            break;
        case MSG_MANAGERSETID5:
            EDIT_SetText(_aahEdit[5][0],"******");
            break;
        case MSG_MANAGERSETID6:
            sprintf(_tmpBuff,"%d",xSysconf.ulDispSleepTime_s/60);
            EDIT_SetText(_aahEdit[6][0],_tmpBuff);
            break;
        default:
            WM_DefaultProc(pMsg);
    }
}
/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE *pMsg)
{
    const void *pData;
    WM_HWIN      hItem;
    U32          FileSize;
    int          NCode;
    int          Id;
    int x, y,Index,_editxoff = 0;
    SCROLLBAR_Handle hScroll;
    SCROLLBAR_Handle wScroll;
    char _tmpBuff[50];
    CON_t *pCon;
//    char buff[500] = "jq\nweqsadddd\nddddddd\ndd\nddd\nddd\nddd\nddd\ndddd\ndddd\nddddn\nddd\ndddddqweqqqqqq\nqqqqqqqqqqqqqqqqq\nqqqqqqqqqqqqqqq\nqqqqqqqq\nqqqqqqqqqqq\nqqqqqqqqqqqqqqqqqqq\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqqqqqqqqqqqqqqwewererryuiuyiuyiaerf\naxzcxzvcbvcbcv";
    pCon = CONGetHandle(0);
    SCROLLBAR_Handle hScrollMul;
    // USER START (Optionally insert additional variables)
    // USER END
    char buff[10];
    uint32_t sizeMul = 0;
        
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
//        //LCD_SetCursor(0,200);
//        WM_SetFocus(pMsg->hWin);
//        /// TODO (zshare#1#): 下面的if不起作用.\
//        但是if里嵌套的if起作用,目前先用此来规避不起作用的if
//        if(_hWinManagerTerminate == cur_win)
//        {
//            /**< 数据处理 */
//            //Data_Process(pMsg);
//            /**< 信号数据处理 */
//            Signal_Show();
//            /**< 灯光控制 */
//            Led_Show();
//            /**< 如果界面发生了切换 */
//            if(_hWinManagerTerminate == cur_win)
//            {
//                /**< 故障分析 */
//                /// TODO (zshare#1#): 滑轮页均不对故障处理.故障界面被滑轮页覆盖
//                //Err_Analy(pMsg->hWin);
//                /**< 特殊触控点分析 */
//                CaliDone_Analy(pMsg->hWin);
//            }
//        }
        break;
    case WM_INIT_DIALOG:
        _x = 0;
        _y = 0;
        // 创建窗口250
        hWindow = pMsg->hWin;//WM_CreateWindow(230, 70, 520, 350, WM_CF_SHOW, &_cbWindow, 0);
//        WM_SetCallback(pMsg->hWin, &_cbWindow);750 276
        multiedit_handler = MULTIEDIT_CreateEx(20, 40, 700, 260, hWindow, WM_CF_SHOW, MULTIEDIT_CI_READONLY, 13, 100, terminateBuff);
        MULTIEDIT_SetTextColor(multiedit_handler,MULTIEDIT_CI_READONLY,GUI_WHITE);
        MULTIEDIT_SetFont(multiedit_handler, &SIF16_Font);
        //MULTIEDIT_SetAutoScrollH(multiedit_handler, 1);
//        MULTIEDIT_SetAutoScrollV(multiedit_handler, 1);
        MULTIEDIT_SetWrapWord(multiedit_handler);
        MULTIEDIT_SetBufferSize(multiedit_handler, 10000);
        MULTIEDIT_SetMaxNumChars(multiedit_handler, 10000);
//        MULTIEDIT_SetHBorder(multiedit_handler,80);//设置边界
        MULTIEDIT_SetInsertMode(multiedit_handler, 0);

        
        hScrollMul = SCROLLBAR_CreateAttached(multiedit_handler, GUI_ID_VSCROLL);
        SCROLLBAR_SetWidth(hScrollMul,30);        
        
        WM_SetStayOnTop(hWindow,1);
        break;
    case WM_NOTIFY_PARENT:
        Id    = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;

        switch(Id) {
        case ID_MULTIEDIT_0: 
            switch (NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                break;
            case WM_NOTIFICATION_RELEASED:
                break;
            case WM_NOTIFICATION_VALUE_CHANGED:
                break;
            }
            break;
        case ID_CHECKBOX_0:
            switch(NCode)
            {
                case WM_NOTIFICATION_CLICKED:
                    hItem = WM_GetDialogItem(pMsg->hWin, ID_CHECKBOX_0);
                    Index = CHECKBOX_GetState(hItem);
                    if((Index == 1)&&(!bittest(_checkbox,0)))
                    {
                        bitset(_checkbox,0);
                        bitclr(_checkbox,1);
                        Index = 0;
                        xSysconf.SetSysCfg(jnSysUSE_GPRSModem,(void *)&Index,ParamTypeU8);
                    }
                    break;
                case WM_NOTIFICATION_RELEASED:
                    break;
                case WM_NOTIFICATION_VALUE_CHANGED:
                    break;
            }
            break;

        case ID_CHECKBOX_1:
            switch(NCode)
            {
                case WM_NOTIFICATION_CLICKED:
                    hItem = WM_GetDialogItem(pMsg->hWin, ID_CHECKBOX_1);
                    Index = CHECKBOX_GetState(hItem);
                    if((Index == 1)&&(!bittest(_checkbox,1)))
                    {
                        bitset(_checkbox,1);
                        bitclr(_checkbox,0);
                        Index = 1;
                        xSysconf.SetSysCfg(jnSysUSE_GPRSModem,(void *)&Index,ParamTypeU8);
                    }
                    break;

                case WM_NOTIFICATION_RELEASED:
                    break;

                case WM_NOTIFICATION_VALUE_CHANGED:
                    break;

            }
            break;
        }
        break;
        // USER START (Optionally insert additional message handling)
    case WM_TIMER:
//        if(pMsg->Data.v == _timerRTC)
//        {
//            /**< 显示时间和日期 */
//            Caculate_RTC_Show(pMsg, ID_TEXT_1, ID_TEXT_2);
//            TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_3), strCSQ);
//            /**< 重启定时器 */
//            WM_RestartTimer(pMsg->Data.v, 20);
//        }
//        if(pMsg->Data.v == _timerSignal)
//        {
//            WM_RestartTimer(pMsg->Data.v, 2000);
//        }
        if(pMsg->Data.v == _timerData)
        {
//            terminaterCount++;
//            memset(buff, '\0', sizeof(buff));
//            sprintf(buff, "%d", terminaterCount);
//            strcat(buff, "次\n");
//        
            extern ring_buffer_s *term_rb;

            if (ring_buffer_len(term_rb) > 0)
            {
                ring_buffer_get(term_rb, strTermCtx, ring_buffer_len(term_rb));
            }
                
            MULTIEDIT_AddText(multiedit_handler, strTermCtx);
            
            sizeMul = MULTIEDIT_GetTextSize(multiedit_handler);
            if (sizeMul > 10000)
            {
                MULTIEDIT_SetBufferSize(multiedit_handler, 10000);
                MULTIEDIT_AddText(multiedit_handler, strTermCtx);
            }
            memset(strTermCtx, 0, sizeof(strTermCtx));
            
            WM_RestartTimer(pMsg->Data.v,500);
        }
        break;
//    case MSG_CREATERRWIN:
//        /**< 故障界面不存在则创建,存在则刷新告警 */
//        err_window(pMsg->hWin);
//        break;
//    case MSG_DELERRWIN:
//        /**< 故障界面存在则删除故障界面 */
//        if(bittest(winCreateFlag,0))
//        {
//            bitclr(winCreateFlag,0);
//            GUI_EndDialog(err_hItem,0);
//            err_hItem = 0;
//        }
//        break;
    case MSG_DELETEMANAGERWIN:
        GUI_EndDialog(_hWinManagerTerminate, 0);
        break;
    default:
        WM_DefaultProc(pMsg);
        break;
    }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/** @brief
 *  输出管理员界面里的系统配置
 * @param
 * @param
 * @return
 *
 *
 *       CreateManagerSysSet
*/
WM_HWIN CreateManagerTerminate(WM_HWIN srcHwin)
{
    _hWinManagerTerminate = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_GetClientWindow(srcHwin), 0, 0);
//    cur_win = _hWinManagerTerminate;
//    _timerRTC = WM_CreateTimer(WM_GetClientWindow(_hWinManagerTerminate), ID_TimerTime, 20, 0);
    _timerData = WM_CreateTimer(WM_GetClientWindow(_hWinManagerTerminate), ID_TimerFlush,1000,0);
//    _timerSignal = WM_CreateTimer(WM_GetClientWindow(_hWinManagerTerminate), ID_TimerSignal,5000,0);
    return _hWinManagerTerminate;
}
/*************************** End of file ****************************/




